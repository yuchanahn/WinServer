// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BASE_H_
#define FLATBUFFERS_GENERATED_BASE_H_

#include "flatbuffers/flatbuffers.h"

struct fheader;
struct fheaderT;

struct fNetEffect;
struct fNetEffectT;

struct fEquipSlots;
struct fEquipSlotsT;

struct Vec3;

struct FirstCharacterData;
struct FirstCharacterDataT;

struct fItem;
struct fItemT;

struct fInventory;
struct fInventoryT;

struct Login;
struct LoginT;

struct id;
struct idT;

struct ping;
struct pingT;

struct test;
struct testT;

struct Player;
struct PlayerT;

struct Monster;
struct MonsterT;

struct MonsterStat;
struct MonsterStatT;

struct PlayerStat;
struct PlayerStatT;

struct SendMeStat;
struct SendMeStatT;

struct Base;
struct BaseT;

enum Class {
  Class_Base = 0,
  Class_Player = 1,
  Class_id = 2,
  Class_test = 3,
  Class_ping = 4,
  Class_PlayerStat = 5,
  Class_SendMeStat = 6,
  Class_Monster = 7,
  Class_MonsterStat = 8,
  Class_LogIn = 9,
  Class_FirstCharacterData = 10,
  Class_fItem = 11,
  Class_fInventory = 12,
  Class_fEquipSlots = 13,
  Class_fheader = 14,
  Class_MIN = Class_Base,
  Class_MAX = Class_fheader
};

inline const Class (&EnumValuesClass())[15] {
  static const Class values[] = {
    Class_Base,
    Class_Player,
    Class_id,
    Class_test,
    Class_ping,
    Class_PlayerStat,
    Class_SendMeStat,
    Class_Monster,
    Class_MonsterStat,
    Class_LogIn,
    Class_FirstCharacterData,
    Class_fItem,
    Class_fInventory,
    Class_fEquipSlots,
    Class_fheader
  };
  return values;
}

inline const char * const *EnumNamesClass() {
  static const char * const names[] = {
    "Base",
    "Player",
    "id",
    "test",
    "ping",
    "PlayerStat",
    "SendMeStat",
    "Monster",
    "MonsterStat",
    "LogIn",
    "FirstCharacterData",
    "fItem",
    "fInventory",
    "fEquipSlots",
    "fheader",
    nullptr
  };
  return names;
}

inline const char *EnumNameClass(Class e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesClass()[index];
}

MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3() {
    memset(this, 0, sizeof(Vec3));
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
STRUCT_END(Vec3, 12);

struct fheaderT : public flatbuffers::NativeTable {
  typedef fheader TableType;
  Class cType;
  int32_t PacketSize;
  fheaderT()
      : cType(Class_Base),
        PacketSize(0) {
  }
};

struct fheader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef fheaderT NativeTableType;
  enum {
    VT_CTYPE = 4,
    VT_PACKETSIZE = 6
  };
  Class cType() const {
    return static_cast<Class>(GetField<int32_t>(VT_CTYPE, 0));
  }
  int32_t PacketSize() const {
    return GetField<int32_t>(VT_PACKETSIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CTYPE) &&
           VerifyField<int32_t>(verifier, VT_PACKETSIZE) &&
           verifier.EndTable();
  }
  fheaderT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(fheaderT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<fheader> Pack(flatbuffers::FlatBufferBuilder &_fbb, const fheaderT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct fheaderBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cType(Class cType) {
    fbb_.AddElement<int32_t>(fheader::VT_CTYPE, static_cast<int32_t>(cType), 0);
  }
  void add_PacketSize(int32_t PacketSize) {
    fbb_.AddElement<int32_t>(fheader::VT_PACKETSIZE, PacketSize, 0);
  }
  explicit fheaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  fheaderBuilder &operator=(const fheaderBuilder &);
  flatbuffers::Offset<fheader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<fheader>(end);
    return o;
  }
};

inline flatbuffers::Offset<fheader> Createfheader(
    flatbuffers::FlatBufferBuilder &_fbb,
    Class cType = Class_Base,
    int32_t PacketSize = 0) {
  fheaderBuilder builder_(_fbb);
  builder_.add_PacketSize(PacketSize);
  builder_.add_cType(cType);
  return builder_.Finish();
}

flatbuffers::Offset<fheader> Createfheader(flatbuffers::FlatBufferBuilder &_fbb, const fheaderT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct fNetEffectT : public flatbuffers::NativeTable {
  typedef fNetEffect TableType;
  Class cType;
  int32_t EffectType;
  int32_t target;
  int32_t targetMonster;
  std::unique_ptr<Vec3> targetPos;
  std::unique_ptr<Vec3> StartPos;
  fNetEffectT()
      : cType(Class_Base),
        EffectType(0),
        target(0),
        targetMonster(0) {
  }
};

struct fNetEffect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef fNetEffectT NativeTableType;
  enum {
    VT_CTYPE = 4,
    VT_EFFECTTYPE = 6,
    VT_TARGET = 8,
    VT_TARGETMONSTER = 10,
    VT_TARGETPOS = 12,
    VT_STARTPOS = 14
  };
  Class cType() const {
    return static_cast<Class>(GetField<int32_t>(VT_CTYPE, 0));
  }
  int32_t EffectType() const {
    return GetField<int32_t>(VT_EFFECTTYPE, 0);
  }
  int32_t target() const {
    return GetField<int32_t>(VT_TARGET, 0);
  }
  int32_t targetMonster() const {
    return GetField<int32_t>(VT_TARGETMONSTER, 0);
  }
  const Vec3 *targetPos() const {
    return GetStruct<const Vec3 *>(VT_TARGETPOS);
  }
  const Vec3 *StartPos() const {
    return GetStruct<const Vec3 *>(VT_STARTPOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CTYPE) &&
           VerifyField<int32_t>(verifier, VT_EFFECTTYPE) &&
           VerifyField<int32_t>(verifier, VT_TARGET) &&
           VerifyField<int32_t>(verifier, VT_TARGETMONSTER) &&
           VerifyField<Vec3>(verifier, VT_TARGETPOS) &&
           VerifyField<Vec3>(verifier, VT_STARTPOS) &&
           verifier.EndTable();
  }
  fNetEffectT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(fNetEffectT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<fNetEffect> Pack(flatbuffers::FlatBufferBuilder &_fbb, const fNetEffectT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct fNetEffectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cType(Class cType) {
    fbb_.AddElement<int32_t>(fNetEffect::VT_CTYPE, static_cast<int32_t>(cType), 0);
  }
  void add_EffectType(int32_t EffectType) {
    fbb_.AddElement<int32_t>(fNetEffect::VT_EFFECTTYPE, EffectType, 0);
  }
  void add_target(int32_t target) {
    fbb_.AddElement<int32_t>(fNetEffect::VT_TARGET, target, 0);
  }
  void add_targetMonster(int32_t targetMonster) {
    fbb_.AddElement<int32_t>(fNetEffect::VT_TARGETMONSTER, targetMonster, 0);
  }
  void add_targetPos(const Vec3 *targetPos) {
    fbb_.AddStruct(fNetEffect::VT_TARGETPOS, targetPos);
  }
  void add_StartPos(const Vec3 *StartPos) {
    fbb_.AddStruct(fNetEffect::VT_STARTPOS, StartPos);
  }
  explicit fNetEffectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  fNetEffectBuilder &operator=(const fNetEffectBuilder &);
  flatbuffers::Offset<fNetEffect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<fNetEffect>(end);
    return o;
  }
};

inline flatbuffers::Offset<fNetEffect> CreatefNetEffect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Class cType = Class_Base,
    int32_t EffectType = 0,
    int32_t target = 0,
    int32_t targetMonster = 0,
    const Vec3 *targetPos = 0,
    const Vec3 *StartPos = 0) {
  fNetEffectBuilder builder_(_fbb);
  builder_.add_StartPos(StartPos);
  builder_.add_targetPos(targetPos);
  builder_.add_targetMonster(targetMonster);
  builder_.add_target(target);
  builder_.add_EffectType(EffectType);
  builder_.add_cType(cType);
  return builder_.Finish();
}

flatbuffers::Offset<fNetEffect> CreatefNetEffect(flatbuffers::FlatBufferBuilder &_fbb, const fNetEffectT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct fEquipSlotsT : public flatbuffers::NativeTable {
  typedef fEquipSlots TableType;
  Class cType;
  std::vector<int32_t> Slot;
  fEquipSlotsT()
      : cType(Class_Base) {
  }
};

struct fEquipSlots FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef fEquipSlotsT NativeTableType;
  enum {
    VT_CTYPE = 4,
    VT_SLOT = 6
  };
  Class cType() const {
    return static_cast<Class>(GetField<int32_t>(VT_CTYPE, 0));
  }
  const flatbuffers::Vector<int32_t> *Slot() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SLOT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CTYPE) &&
           VerifyOffset(verifier, VT_SLOT) &&
           verifier.Verify(Slot()) &&
           verifier.EndTable();
  }
  fEquipSlotsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(fEquipSlotsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<fEquipSlots> Pack(flatbuffers::FlatBufferBuilder &_fbb, const fEquipSlotsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct fEquipSlotsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cType(Class cType) {
    fbb_.AddElement<int32_t>(fEquipSlots::VT_CTYPE, static_cast<int32_t>(cType), 0);
  }
  void add_Slot(flatbuffers::Offset<flatbuffers::Vector<int32_t>> Slot) {
    fbb_.AddOffset(fEquipSlots::VT_SLOT, Slot);
  }
  explicit fEquipSlotsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  fEquipSlotsBuilder &operator=(const fEquipSlotsBuilder &);
  flatbuffers::Offset<fEquipSlots> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<fEquipSlots>(end);
    return o;
  }
};

inline flatbuffers::Offset<fEquipSlots> CreatefEquipSlots(
    flatbuffers::FlatBufferBuilder &_fbb,
    Class cType = Class_Base,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> Slot = 0) {
  fEquipSlotsBuilder builder_(_fbb);
  builder_.add_Slot(Slot);
  builder_.add_cType(cType);
  return builder_.Finish();
}

inline flatbuffers::Offset<fEquipSlots> CreatefEquipSlotsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Class cType = Class_Base,
    const std::vector<int32_t> *Slot = nullptr) {
  return CreatefEquipSlots(
      _fbb,
      cType,
      Slot ? _fbb.CreateVector<int32_t>(*Slot) : 0);
}

flatbuffers::Offset<fEquipSlots> CreatefEquipSlots(flatbuffers::FlatBufferBuilder &_fbb, const fEquipSlotsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FirstCharacterDataT : public flatbuffers::NativeTable {
  typedef FirstCharacterData TableType;
  Class cType;
  std::unique_ptr<Vec3> Pos;
  std::string Name;
  int32_t HP;
  int32_t HPLim;
  int32_t MP;
  int32_t MPLim;
  int32_t EXP;
  int32_t Attack;
  int32_t LV;
  int32_t ID;
  FirstCharacterDataT()
      : cType(Class_Base),
        HP(0),
        HPLim(0),
        MP(0),
        MPLim(0),
        EXP(0),
        Attack(0),
        LV(0),
        ID(0) {
  }
};

struct FirstCharacterData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FirstCharacterDataT NativeTableType;
  enum {
    VT_CTYPE = 4,
    VT_POS = 6,
    VT_NAME = 8,
    VT_HP = 10,
    VT_HPLIM = 12,
    VT_MP = 14,
    VT_MPLIM = 16,
    VT_EXP = 18,
    VT_ATTACK = 20,
    VT_LV = 22,
    VT_ID = 24
  };
  Class cType() const {
    return static_cast<Class>(GetField<int32_t>(VT_CTYPE, 0));
  }
  const Vec3 *Pos() const {
    return GetStruct<const Vec3 *>(VT_POS);
  }
  const flatbuffers::String *Name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t HP() const {
    return GetField<int32_t>(VT_HP, 0);
  }
  int32_t HPLim() const {
    return GetField<int32_t>(VT_HPLIM, 0);
  }
  int32_t MP() const {
    return GetField<int32_t>(VT_MP, 0);
  }
  int32_t MPLim() const {
    return GetField<int32_t>(VT_MPLIM, 0);
  }
  int32_t EXP() const {
    return GetField<int32_t>(VT_EXP, 0);
  }
  int32_t Attack() const {
    return GetField<int32_t>(VT_ATTACK, 0);
  }
  int32_t LV() const {
    return GetField<int32_t>(VT_LV, 0);
  }
  int32_t ID() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CTYPE) &&
           VerifyField<Vec3>(verifier, VT_POS) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(Name()) &&
           VerifyField<int32_t>(verifier, VT_HP) &&
           VerifyField<int32_t>(verifier, VT_HPLIM) &&
           VerifyField<int32_t>(verifier, VT_MP) &&
           VerifyField<int32_t>(verifier, VT_MPLIM) &&
           VerifyField<int32_t>(verifier, VT_EXP) &&
           VerifyField<int32_t>(verifier, VT_ATTACK) &&
           VerifyField<int32_t>(verifier, VT_LV) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
  FirstCharacterDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FirstCharacterDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FirstCharacterData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FirstCharacterDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FirstCharacterDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cType(Class cType) {
    fbb_.AddElement<int32_t>(FirstCharacterData::VT_CTYPE, static_cast<int32_t>(cType), 0);
  }
  void add_Pos(const Vec3 *Pos) {
    fbb_.AddStruct(FirstCharacterData::VT_POS, Pos);
  }
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) {
    fbb_.AddOffset(FirstCharacterData::VT_NAME, Name);
  }
  void add_HP(int32_t HP) {
    fbb_.AddElement<int32_t>(FirstCharacterData::VT_HP, HP, 0);
  }
  void add_HPLim(int32_t HPLim) {
    fbb_.AddElement<int32_t>(FirstCharacterData::VT_HPLIM, HPLim, 0);
  }
  void add_MP(int32_t MP) {
    fbb_.AddElement<int32_t>(FirstCharacterData::VT_MP, MP, 0);
  }
  void add_MPLim(int32_t MPLim) {
    fbb_.AddElement<int32_t>(FirstCharacterData::VT_MPLIM, MPLim, 0);
  }
  void add_EXP(int32_t EXP) {
    fbb_.AddElement<int32_t>(FirstCharacterData::VT_EXP, EXP, 0);
  }
  void add_Attack(int32_t Attack) {
    fbb_.AddElement<int32_t>(FirstCharacterData::VT_ATTACK, Attack, 0);
  }
  void add_LV(int32_t LV) {
    fbb_.AddElement<int32_t>(FirstCharacterData::VT_LV, LV, 0);
  }
  void add_ID(int32_t ID) {
    fbb_.AddElement<int32_t>(FirstCharacterData::VT_ID, ID, 0);
  }
  explicit FirstCharacterDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FirstCharacterDataBuilder &operator=(const FirstCharacterDataBuilder &);
  flatbuffers::Offset<FirstCharacterData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FirstCharacterData>(end);
    return o;
  }
};

inline flatbuffers::Offset<FirstCharacterData> CreateFirstCharacterData(
    flatbuffers::FlatBufferBuilder &_fbb,
    Class cType = Class_Base,
    const Vec3 *Pos = 0,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    int32_t HP = 0,
    int32_t HPLim = 0,
    int32_t MP = 0,
    int32_t MPLim = 0,
    int32_t EXP = 0,
    int32_t Attack = 0,
    int32_t LV = 0,
    int32_t ID = 0) {
  FirstCharacterDataBuilder builder_(_fbb);
  builder_.add_ID(ID);
  builder_.add_LV(LV);
  builder_.add_Attack(Attack);
  builder_.add_EXP(EXP);
  builder_.add_MPLim(MPLim);
  builder_.add_MP(MP);
  builder_.add_HPLim(HPLim);
  builder_.add_HP(HP);
  builder_.add_Name(Name);
  builder_.add_Pos(Pos);
  builder_.add_cType(cType);
  return builder_.Finish();
}

inline flatbuffers::Offset<FirstCharacterData> CreateFirstCharacterDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Class cType = Class_Base,
    const Vec3 *Pos = 0,
    const char *Name = nullptr,
    int32_t HP = 0,
    int32_t HPLim = 0,
    int32_t MP = 0,
    int32_t MPLim = 0,
    int32_t EXP = 0,
    int32_t Attack = 0,
    int32_t LV = 0,
    int32_t ID = 0) {
  return CreateFirstCharacterData(
      _fbb,
      cType,
      Pos,
      Name ? _fbb.CreateString(Name) : 0,
      HP,
      HPLim,
      MP,
      MPLim,
      EXP,
      Attack,
      LV,
      ID);
}

flatbuffers::Offset<FirstCharacterData> CreateFirstCharacterData(flatbuffers::FlatBufferBuilder &_fbb, const FirstCharacterDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct fItemT : public flatbuffers::NativeTable {
  typedef fItem TableType;
  Class cType;
  int32_t id;
  std::string name;
  int32_t type;
  int32_t val1;
  int32_t val2;
  int32_t val3;
  int32_t val4;
  int32_t val5;
  int32_t val6;
  int32_t val7;
  int32_t val8;
  int32_t count;
  fItemT()
      : cType(Class_Base),
        id(0),
        type(0),
        val1(0),
        val2(0),
        val3(0),
        val4(0),
        val5(0),
        val6(0),
        val7(0),
        val8(0),
        count(0) {
  }
};

struct fItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef fItemT NativeTableType;
  enum {
    VT_CTYPE = 4,
    VT_ID = 6,
    VT_NAME = 8,
    VT_TYPE = 10,
    VT_VAL1 = 12,
    VT_VAL2 = 14,
    VT_VAL3 = 16,
    VT_VAL4 = 18,
    VT_VAL5 = 20,
    VT_VAL6 = 22,
    VT_VAL7 = 24,
    VT_VAL8 = 26,
    VT_COUNT = 28
  };
  Class cType() const {
    return static_cast<Class>(GetField<int32_t>(VT_CTYPE, 0));
  }
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  int32_t val1() const {
    return GetField<int32_t>(VT_VAL1, 0);
  }
  int32_t val2() const {
    return GetField<int32_t>(VT_VAL2, 0);
  }
  int32_t val3() const {
    return GetField<int32_t>(VT_VAL3, 0);
  }
  int32_t val4() const {
    return GetField<int32_t>(VT_VAL4, 0);
  }
  int32_t val5() const {
    return GetField<int32_t>(VT_VAL5, 0);
  }
  int32_t val6() const {
    return GetField<int32_t>(VT_VAL6, 0);
  }
  int32_t val7() const {
    return GetField<int32_t>(VT_VAL7, 0);
  }
  int32_t val8() const {
    return GetField<int32_t>(VT_VAL8, 0);
  }
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CTYPE) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_VAL1) &&
           VerifyField<int32_t>(verifier, VT_VAL2) &&
           VerifyField<int32_t>(verifier, VT_VAL3) &&
           VerifyField<int32_t>(verifier, VT_VAL4) &&
           VerifyField<int32_t>(verifier, VT_VAL5) &&
           VerifyField<int32_t>(verifier, VT_VAL6) &&
           VerifyField<int32_t>(verifier, VT_VAL7) &&
           VerifyField<int32_t>(verifier, VT_VAL8) &&
           VerifyField<int32_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
  fItemT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(fItemT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<fItem> Pack(flatbuffers::FlatBufferBuilder &_fbb, const fItemT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct fItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cType(Class cType) {
    fbb_.AddElement<int32_t>(fItem::VT_CTYPE, static_cast<int32_t>(cType), 0);
  }
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(fItem::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(fItem::VT_NAME, name);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(fItem::VT_TYPE, type, 0);
  }
  void add_val1(int32_t val1) {
    fbb_.AddElement<int32_t>(fItem::VT_VAL1, val1, 0);
  }
  void add_val2(int32_t val2) {
    fbb_.AddElement<int32_t>(fItem::VT_VAL2, val2, 0);
  }
  void add_val3(int32_t val3) {
    fbb_.AddElement<int32_t>(fItem::VT_VAL3, val3, 0);
  }
  void add_val4(int32_t val4) {
    fbb_.AddElement<int32_t>(fItem::VT_VAL4, val4, 0);
  }
  void add_val5(int32_t val5) {
    fbb_.AddElement<int32_t>(fItem::VT_VAL5, val5, 0);
  }
  void add_val6(int32_t val6) {
    fbb_.AddElement<int32_t>(fItem::VT_VAL6, val6, 0);
  }
  void add_val7(int32_t val7) {
    fbb_.AddElement<int32_t>(fItem::VT_VAL7, val7, 0);
  }
  void add_val8(int32_t val8) {
    fbb_.AddElement<int32_t>(fItem::VT_VAL8, val8, 0);
  }
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(fItem::VT_COUNT, count, 0);
  }
  explicit fItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  fItemBuilder &operator=(const fItemBuilder &);
  flatbuffers::Offset<fItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<fItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<fItem> CreatefItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    Class cType = Class_Base,
    int32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t type = 0,
    int32_t val1 = 0,
    int32_t val2 = 0,
    int32_t val3 = 0,
    int32_t val4 = 0,
    int32_t val5 = 0,
    int32_t val6 = 0,
    int32_t val7 = 0,
    int32_t val8 = 0,
    int32_t count = 0) {
  fItemBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_val8(val8);
  builder_.add_val7(val7);
  builder_.add_val6(val6);
  builder_.add_val5(val5);
  builder_.add_val4(val4);
  builder_.add_val3(val3);
  builder_.add_val2(val2);
  builder_.add_val1(val1);
  builder_.add_type(type);
  builder_.add_name(name);
  builder_.add_id(id);
  builder_.add_cType(cType);
  return builder_.Finish();
}

inline flatbuffers::Offset<fItem> CreatefItemDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Class cType = Class_Base,
    int32_t id = 0,
    const char *name = nullptr,
    int32_t type = 0,
    int32_t val1 = 0,
    int32_t val2 = 0,
    int32_t val3 = 0,
    int32_t val4 = 0,
    int32_t val5 = 0,
    int32_t val6 = 0,
    int32_t val7 = 0,
    int32_t val8 = 0,
    int32_t count = 0) {
  return CreatefItem(
      _fbb,
      cType,
      id,
      name ? _fbb.CreateString(name) : 0,
      type,
      val1,
      val2,
      val3,
      val4,
      val5,
      val6,
      val7,
      val8,
      count);
}

flatbuffers::Offset<fItem> CreatefItem(flatbuffers::FlatBufferBuilder &_fbb, const fItemT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct fInventoryT : public flatbuffers::NativeTable {
  typedef fInventory TableType;
  Class cType;
  std::vector<int32_t> Slot;
  fInventoryT()
      : cType(Class_Base) {
  }
};

struct fInventory FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef fInventoryT NativeTableType;
  enum {
    VT_CTYPE = 4,
    VT_SLOT = 6
  };
  Class cType() const {
    return static_cast<Class>(GetField<int32_t>(VT_CTYPE, 0));
  }
  const flatbuffers::Vector<int32_t> *Slot() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SLOT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CTYPE) &&
           VerifyOffset(verifier, VT_SLOT) &&
           verifier.Verify(Slot()) &&
           verifier.EndTable();
  }
  fInventoryT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(fInventoryT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<fInventory> Pack(flatbuffers::FlatBufferBuilder &_fbb, const fInventoryT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct fInventoryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cType(Class cType) {
    fbb_.AddElement<int32_t>(fInventory::VT_CTYPE, static_cast<int32_t>(cType), 0);
  }
  void add_Slot(flatbuffers::Offset<flatbuffers::Vector<int32_t>> Slot) {
    fbb_.AddOffset(fInventory::VT_SLOT, Slot);
  }
  explicit fInventoryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  fInventoryBuilder &operator=(const fInventoryBuilder &);
  flatbuffers::Offset<fInventory> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<fInventory>(end);
    return o;
  }
};

inline flatbuffers::Offset<fInventory> CreatefInventory(
    flatbuffers::FlatBufferBuilder &_fbb,
    Class cType = Class_Base,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> Slot = 0) {
  fInventoryBuilder builder_(_fbb);
  builder_.add_Slot(Slot);
  builder_.add_cType(cType);
  return builder_.Finish();
}

inline flatbuffers::Offset<fInventory> CreatefInventoryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Class cType = Class_Base,
    const std::vector<int32_t> *Slot = nullptr) {
  return CreatefInventory(
      _fbb,
      cType,
      Slot ? _fbb.CreateVector<int32_t>(*Slot) : 0);
}

flatbuffers::Offset<fInventory> CreatefInventory(flatbuffers::FlatBufferBuilder &_fbb, const fInventoryT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LoginT : public flatbuffers::NativeTable {
  typedef Login TableType;
  Class cType;
  bool isSignin;
  std::string id;
  std::string pass;
  bool isSuccess;
  LoginT()
      : cType(Class_Base),
        isSignin(false),
        isSuccess(false) {
  }
};

struct Login FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LoginT NativeTableType;
  enum {
    VT_CTYPE = 4,
    VT_ISSIGNIN = 6,
    VT_ID = 8,
    VT_PASS = 10,
    VT_ISSUCCESS = 12
  };
  Class cType() const {
    return static_cast<Class>(GetField<int32_t>(VT_CTYPE, 0));
  }
  bool isSignin() const {
    return GetField<uint8_t>(VT_ISSIGNIN, 0) != 0;
  }
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *pass() const {
    return GetPointer<const flatbuffers::String *>(VT_PASS);
  }
  bool isSuccess() const {
    return GetField<uint8_t>(VT_ISSUCCESS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CTYPE) &&
           VerifyField<uint8_t>(verifier, VT_ISSIGNIN) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.Verify(id()) &&
           VerifyOffset(verifier, VT_PASS) &&
           verifier.Verify(pass()) &&
           VerifyField<uint8_t>(verifier, VT_ISSUCCESS) &&
           verifier.EndTable();
  }
  LoginT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LoginT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Login> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoginT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LoginBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cType(Class cType) {
    fbb_.AddElement<int32_t>(Login::VT_CTYPE, static_cast<int32_t>(cType), 0);
  }
  void add_isSignin(bool isSignin) {
    fbb_.AddElement<uint8_t>(Login::VT_ISSIGNIN, static_cast<uint8_t>(isSignin), 0);
  }
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Login::VT_ID, id);
  }
  void add_pass(flatbuffers::Offset<flatbuffers::String> pass) {
    fbb_.AddOffset(Login::VT_PASS, pass);
  }
  void add_isSuccess(bool isSuccess) {
    fbb_.AddElement<uint8_t>(Login::VT_ISSUCCESS, static_cast<uint8_t>(isSuccess), 0);
  }
  explicit LoginBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LoginBuilder &operator=(const LoginBuilder &);
  flatbuffers::Offset<Login> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Login>(end);
    return o;
  }
};

inline flatbuffers::Offset<Login> CreateLogin(
    flatbuffers::FlatBufferBuilder &_fbb,
    Class cType = Class_Base,
    bool isSignin = false,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> pass = 0,
    bool isSuccess = false) {
  LoginBuilder builder_(_fbb);
  builder_.add_pass(pass);
  builder_.add_id(id);
  builder_.add_cType(cType);
  builder_.add_isSuccess(isSuccess);
  builder_.add_isSignin(isSignin);
  return builder_.Finish();
}

inline flatbuffers::Offset<Login> CreateLoginDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Class cType = Class_Base,
    bool isSignin = false,
    const char *id = nullptr,
    const char *pass = nullptr,
    bool isSuccess = false) {
  return CreateLogin(
      _fbb,
      cType,
      isSignin,
      id ? _fbb.CreateString(id) : 0,
      pass ? _fbb.CreateString(pass) : 0,
      isSuccess);
}

flatbuffers::Offset<Login> CreateLogin(flatbuffers::FlatBufferBuilder &_fbb, const LoginT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct idT : public flatbuffers::NativeTable {
  typedef id TableType;
  Class cType;
  int32_t ID;
  idT()
      : cType(Class_Base),
        ID(0) {
  }
};

struct id FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef idT NativeTableType;
  enum {
    VT_CTYPE = 4,
    VT_ID = 6
  };
  Class cType() const {
    return static_cast<Class>(GetField<int32_t>(VT_CTYPE, 0));
  }
  int32_t ID() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CTYPE) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
  idT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(idT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<id> Pack(flatbuffers::FlatBufferBuilder &_fbb, const idT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct idBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cType(Class cType) {
    fbb_.AddElement<int32_t>(id::VT_CTYPE, static_cast<int32_t>(cType), 0);
  }
  void add_ID(int32_t ID) {
    fbb_.AddElement<int32_t>(id::VT_ID, ID, 0);
  }
  explicit idBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  idBuilder &operator=(const idBuilder &);
  flatbuffers::Offset<id> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<id>(end);
    return o;
  }
};

inline flatbuffers::Offset<id> Createid(
    flatbuffers::FlatBufferBuilder &_fbb,
    Class cType = Class_Base,
    int32_t ID = 0) {
  idBuilder builder_(_fbb);
  builder_.add_ID(ID);
  builder_.add_cType(cType);
  return builder_.Finish();
}

flatbuffers::Offset<id> Createid(flatbuffers::FlatBufferBuilder &_fbb, const idT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct pingT : public flatbuffers::NativeTable {
  typedef ping TableType;
  Class cType;
  int64_t time;
  pingT()
      : cType(Class_Base),
        time(0) {
  }
};

struct ping FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef pingT NativeTableType;
  enum {
    VT_CTYPE = 4,
    VT_TIME = 6
  };
  Class cType() const {
    return static_cast<Class>(GetField<int32_t>(VT_CTYPE, 0));
  }
  int64_t time() const {
    return GetField<int64_t>(VT_TIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CTYPE) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           verifier.EndTable();
  }
  pingT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(pingT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ping> Pack(flatbuffers::FlatBufferBuilder &_fbb, const pingT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct pingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cType(Class cType) {
    fbb_.AddElement<int32_t>(ping::VT_CTYPE, static_cast<int32_t>(cType), 0);
  }
  void add_time(int64_t time) {
    fbb_.AddElement<int64_t>(ping::VT_TIME, time, 0);
  }
  explicit pingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  pingBuilder &operator=(const pingBuilder &);
  flatbuffers::Offset<ping> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ping>(end);
    return o;
  }
};

inline flatbuffers::Offset<ping> Createping(
    flatbuffers::FlatBufferBuilder &_fbb,
    Class cType = Class_Base,
    int64_t time = 0) {
  pingBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_cType(cType);
  return builder_.Finish();
}

flatbuffers::Offset<ping> Createping(flatbuffers::FlatBufferBuilder &_fbb, const pingT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct testT : public flatbuffers::NativeTable {
  typedef test TableType;
  Class cType;
  int64_t num;
  testT()
      : cType(Class_Base),
        num(0) {
  }
};

struct test FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef testT NativeTableType;
  enum {
    VT_CTYPE = 4,
    VT_NUM = 6
  };
  Class cType() const {
    return static_cast<Class>(GetField<int32_t>(VT_CTYPE, 0));
  }
  int64_t num() const {
    return GetField<int64_t>(VT_NUM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CTYPE) &&
           VerifyField<int64_t>(verifier, VT_NUM) &&
           verifier.EndTable();
  }
  testT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(testT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<test> Pack(flatbuffers::FlatBufferBuilder &_fbb, const testT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct testBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cType(Class cType) {
    fbb_.AddElement<int32_t>(test::VT_CTYPE, static_cast<int32_t>(cType), 0);
  }
  void add_num(int64_t num) {
    fbb_.AddElement<int64_t>(test::VT_NUM, num, 0);
  }
  explicit testBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  testBuilder &operator=(const testBuilder &);
  flatbuffers::Offset<test> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<test>(end);
    return o;
  }
};

inline flatbuffers::Offset<test> Createtest(
    flatbuffers::FlatBufferBuilder &_fbb,
    Class cType = Class_Base,
    int64_t num = 0) {
  testBuilder builder_(_fbb);
  builder_.add_num(num);
  builder_.add_cType(cType);
  return builder_.Finish();
}

flatbuffers::Offset<test> Createtest(flatbuffers::FlatBufferBuilder &_fbb, const testT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PlayerT : public flatbuffers::NativeTable {
  typedef Player TableType;
  Class cType;
  std::unique_ptr<Vec3> pos;
  std::unique_ptr<Vec3> vel;
  std::unique_ptr<Vec3> rot;
  float w;
  int32_t ID;
  float Vertical;
  float Horizontal;
  bool Jump;
  bool Attack;
  float Anicode;
  bool Run;
  PlayerT()
      : cType(Class_Base),
        w(0.0f),
        ID(0),
        Vertical(0.0f),
        Horizontal(0.0f),
        Jump(false),
        Attack(false),
        Anicode(0.0f),
        Run(false) {
  }
};

struct Player FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PlayerT NativeTableType;
  enum {
    VT_CTYPE = 4,
    VT_POS = 6,
    VT_VEL = 8,
    VT_ROT = 10,
    VT_W = 12,
    VT_ID = 14,
    VT_VERTICAL = 16,
    VT_HORIZONTAL = 18,
    VT_JUMP = 20,
    VT_ATTACK = 22,
    VT_ANICODE = 24,
    VT_RUN = 26
  };
  Class cType() const {
    return static_cast<Class>(GetField<int32_t>(VT_CTYPE, 0));
  }
  const Vec3 *pos() const {
    return GetStruct<const Vec3 *>(VT_POS);
  }
  const Vec3 *vel() const {
    return GetStruct<const Vec3 *>(VT_VEL);
  }
  const Vec3 *rot() const {
    return GetStruct<const Vec3 *>(VT_ROT);
  }
  float w() const {
    return GetField<float>(VT_W, 0.0f);
  }
  int32_t ID() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  float Vertical() const {
    return GetField<float>(VT_VERTICAL, 0.0f);
  }
  float Horizontal() const {
    return GetField<float>(VT_HORIZONTAL, 0.0f);
  }
  bool Jump() const {
    return GetField<uint8_t>(VT_JUMP, 0) != 0;
  }
  bool Attack() const {
    return GetField<uint8_t>(VT_ATTACK, 0) != 0;
  }
  float Anicode() const {
    return GetField<float>(VT_ANICODE, 0.0f);
  }
  bool Run() const {
    return GetField<uint8_t>(VT_RUN, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CTYPE) &&
           VerifyField<Vec3>(verifier, VT_POS) &&
           VerifyField<Vec3>(verifier, VT_VEL) &&
           VerifyField<Vec3>(verifier, VT_ROT) &&
           VerifyField<float>(verifier, VT_W) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<float>(verifier, VT_VERTICAL) &&
           VerifyField<float>(verifier, VT_HORIZONTAL) &&
           VerifyField<uint8_t>(verifier, VT_JUMP) &&
           VerifyField<uint8_t>(verifier, VT_ATTACK) &&
           VerifyField<float>(verifier, VT_ANICODE) &&
           VerifyField<uint8_t>(verifier, VT_RUN) &&
           verifier.EndTable();
  }
  PlayerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PlayerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Player> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlayerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PlayerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cType(Class cType) {
    fbb_.AddElement<int32_t>(Player::VT_CTYPE, static_cast<int32_t>(cType), 0);
  }
  void add_pos(const Vec3 *pos) {
    fbb_.AddStruct(Player::VT_POS, pos);
  }
  void add_vel(const Vec3 *vel) {
    fbb_.AddStruct(Player::VT_VEL, vel);
  }
  void add_rot(const Vec3 *rot) {
    fbb_.AddStruct(Player::VT_ROT, rot);
  }
  void add_w(float w) {
    fbb_.AddElement<float>(Player::VT_W, w, 0.0f);
  }
  void add_ID(int32_t ID) {
    fbb_.AddElement<int32_t>(Player::VT_ID, ID, 0);
  }
  void add_Vertical(float Vertical) {
    fbb_.AddElement<float>(Player::VT_VERTICAL, Vertical, 0.0f);
  }
  void add_Horizontal(float Horizontal) {
    fbb_.AddElement<float>(Player::VT_HORIZONTAL, Horizontal, 0.0f);
  }
  void add_Jump(bool Jump) {
    fbb_.AddElement<uint8_t>(Player::VT_JUMP, static_cast<uint8_t>(Jump), 0);
  }
  void add_Attack(bool Attack) {
    fbb_.AddElement<uint8_t>(Player::VT_ATTACK, static_cast<uint8_t>(Attack), 0);
  }
  void add_Anicode(float Anicode) {
    fbb_.AddElement<float>(Player::VT_ANICODE, Anicode, 0.0f);
  }
  void add_Run(bool Run) {
    fbb_.AddElement<uint8_t>(Player::VT_RUN, static_cast<uint8_t>(Run), 0);
  }
  explicit PlayerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayerBuilder &operator=(const PlayerBuilder &);
  flatbuffers::Offset<Player> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Player>(end);
    return o;
  }
};

inline flatbuffers::Offset<Player> CreatePlayer(
    flatbuffers::FlatBufferBuilder &_fbb,
    Class cType = Class_Base,
    const Vec3 *pos = 0,
    const Vec3 *vel = 0,
    const Vec3 *rot = 0,
    float w = 0.0f,
    int32_t ID = 0,
    float Vertical = 0.0f,
    float Horizontal = 0.0f,
    bool Jump = false,
    bool Attack = false,
    float Anicode = 0.0f,
    bool Run = false) {
  PlayerBuilder builder_(_fbb);
  builder_.add_Anicode(Anicode);
  builder_.add_Horizontal(Horizontal);
  builder_.add_Vertical(Vertical);
  builder_.add_ID(ID);
  builder_.add_w(w);
  builder_.add_rot(rot);
  builder_.add_vel(vel);
  builder_.add_pos(pos);
  builder_.add_cType(cType);
  builder_.add_Run(Run);
  builder_.add_Attack(Attack);
  builder_.add_Jump(Jump);
  return builder_.Finish();
}

flatbuffers::Offset<Player> CreatePlayer(flatbuffers::FlatBufferBuilder &_fbb, const PlayerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MonsterT : public flatbuffers::NativeTable {
  typedef Monster TableType;
  Class cType;
  std::unique_ptr<Vec3> pos;
  int32_t ID;
  int32_t TargetID;
  std::unique_ptr<Vec3> TargetPos;
  float Ani;
  MonsterT()
      : cType(Class_Base),
        ID(0),
        TargetID(0),
        Ani(0.0f) {
  }
};

struct Monster FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MonsterT NativeTableType;
  enum {
    VT_CTYPE = 4,
    VT_POS = 6,
    VT_ID = 8,
    VT_TARGETID = 10,
    VT_TARGETPOS = 12,
    VT_ANI = 14
  };
  Class cType() const {
    return static_cast<Class>(GetField<int32_t>(VT_CTYPE, 0));
  }
  const Vec3 *pos() const {
    return GetStruct<const Vec3 *>(VT_POS);
  }
  int32_t ID() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t TargetID() const {
    return GetField<int32_t>(VT_TARGETID, 0);
  }
  const Vec3 *TargetPos() const {
    return GetStruct<const Vec3 *>(VT_TARGETPOS);
  }
  float Ani() const {
    return GetField<float>(VT_ANI, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CTYPE) &&
           VerifyField<Vec3>(verifier, VT_POS) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int32_t>(verifier, VT_TARGETID) &&
           VerifyField<Vec3>(verifier, VT_TARGETPOS) &&
           VerifyField<float>(verifier, VT_ANI) &&
           verifier.EndTable();
  }
  MonsterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MonsterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Monster> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MonsterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MonsterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cType(Class cType) {
    fbb_.AddElement<int32_t>(Monster::VT_CTYPE, static_cast<int32_t>(cType), 0);
  }
  void add_pos(const Vec3 *pos) {
    fbb_.AddStruct(Monster::VT_POS, pos);
  }
  void add_ID(int32_t ID) {
    fbb_.AddElement<int32_t>(Monster::VT_ID, ID, 0);
  }
  void add_TargetID(int32_t TargetID) {
    fbb_.AddElement<int32_t>(Monster::VT_TARGETID, TargetID, 0);
  }
  void add_TargetPos(const Vec3 *TargetPos) {
    fbb_.AddStruct(Monster::VT_TARGETPOS, TargetPos);
  }
  void add_Ani(float Ani) {
    fbb_.AddElement<float>(Monster::VT_ANI, Ani, 0.0f);
  }
  explicit MonsterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MonsterBuilder &operator=(const MonsterBuilder &);
  flatbuffers::Offset<Monster> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Monster>(end);
    return o;
  }
};

inline flatbuffers::Offset<Monster> CreateMonster(
    flatbuffers::FlatBufferBuilder &_fbb,
    Class cType = Class_Base,
    const Vec3 *pos = 0,
    int32_t ID = 0,
    int32_t TargetID = 0,
    const Vec3 *TargetPos = 0,
    float Ani = 0.0f) {
  MonsterBuilder builder_(_fbb);
  builder_.add_Ani(Ani);
  builder_.add_TargetPos(TargetPos);
  builder_.add_TargetID(TargetID);
  builder_.add_ID(ID);
  builder_.add_pos(pos);
  builder_.add_cType(cType);
  return builder_.Finish();
}

flatbuffers::Offset<Monster> CreateMonster(flatbuffers::FlatBufferBuilder &_fbb, const MonsterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MonsterStatT : public flatbuffers::NativeTable {
  typedef MonsterStat TableType;
  Class cType;
  int32_t HP;
  int32_t MAXHP;
  int32_t ID;
  MonsterStatT()
      : cType(Class_Base),
        HP(0),
        MAXHP(0),
        ID(0) {
  }
};

struct MonsterStat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MonsterStatT NativeTableType;
  enum {
    VT_CTYPE = 4,
    VT_HP = 6,
    VT_MAXHP = 8,
    VT_ID = 10
  };
  Class cType() const {
    return static_cast<Class>(GetField<int32_t>(VT_CTYPE, 0));
  }
  int32_t HP() const {
    return GetField<int32_t>(VT_HP, 0);
  }
  int32_t MAXHP() const {
    return GetField<int32_t>(VT_MAXHP, 0);
  }
  int32_t ID() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CTYPE) &&
           VerifyField<int32_t>(verifier, VT_HP) &&
           VerifyField<int32_t>(verifier, VT_MAXHP) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
  MonsterStatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MonsterStatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MonsterStat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MonsterStatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MonsterStatBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cType(Class cType) {
    fbb_.AddElement<int32_t>(MonsterStat::VT_CTYPE, static_cast<int32_t>(cType), 0);
  }
  void add_HP(int32_t HP) {
    fbb_.AddElement<int32_t>(MonsterStat::VT_HP, HP, 0);
  }
  void add_MAXHP(int32_t MAXHP) {
    fbb_.AddElement<int32_t>(MonsterStat::VT_MAXHP, MAXHP, 0);
  }
  void add_ID(int32_t ID) {
    fbb_.AddElement<int32_t>(MonsterStat::VT_ID, ID, 0);
  }
  explicit MonsterStatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MonsterStatBuilder &operator=(const MonsterStatBuilder &);
  flatbuffers::Offset<MonsterStat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MonsterStat>(end);
    return o;
  }
};

inline flatbuffers::Offset<MonsterStat> CreateMonsterStat(
    flatbuffers::FlatBufferBuilder &_fbb,
    Class cType = Class_Base,
    int32_t HP = 0,
    int32_t MAXHP = 0,
    int32_t ID = 0) {
  MonsterStatBuilder builder_(_fbb);
  builder_.add_ID(ID);
  builder_.add_MAXHP(MAXHP);
  builder_.add_HP(HP);
  builder_.add_cType(cType);
  return builder_.Finish();
}

flatbuffers::Offset<MonsterStat> CreateMonsterStat(flatbuffers::FlatBufferBuilder &_fbb, const MonsterStatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PlayerStatT : public flatbuffers::NativeTable {
  typedef PlayerStat TableType;
  Class cType;
  int32_t HP;
  int32_t HPLim;
  int32_t MP;
  int32_t MPLim;
  int32_t EXP;
  int32_t Attack;
  int32_t LV;
  int32_t ID;
  PlayerStatT()
      : cType(Class_Base),
        HP(0),
        HPLim(0),
        MP(0),
        MPLim(0),
        EXP(0),
        Attack(0),
        LV(0),
        ID(0) {
  }
};

struct PlayerStat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PlayerStatT NativeTableType;
  enum {
    VT_CTYPE = 4,
    VT_HP = 6,
    VT_HPLIM = 8,
    VT_MP = 10,
    VT_MPLIM = 12,
    VT_EXP = 14,
    VT_ATTACK = 16,
    VT_LV = 18,
    VT_ID = 20
  };
  Class cType() const {
    return static_cast<Class>(GetField<int32_t>(VT_CTYPE, 0));
  }
  int32_t HP() const {
    return GetField<int32_t>(VT_HP, 0);
  }
  int32_t HPLim() const {
    return GetField<int32_t>(VT_HPLIM, 0);
  }
  int32_t MP() const {
    return GetField<int32_t>(VT_MP, 0);
  }
  int32_t MPLim() const {
    return GetField<int32_t>(VT_MPLIM, 0);
  }
  int32_t EXP() const {
    return GetField<int32_t>(VT_EXP, 0);
  }
  int32_t Attack() const {
    return GetField<int32_t>(VT_ATTACK, 0);
  }
  int32_t LV() const {
    return GetField<int32_t>(VT_LV, 0);
  }
  int32_t ID() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CTYPE) &&
           VerifyField<int32_t>(verifier, VT_HP) &&
           VerifyField<int32_t>(verifier, VT_HPLIM) &&
           VerifyField<int32_t>(verifier, VT_MP) &&
           VerifyField<int32_t>(verifier, VT_MPLIM) &&
           VerifyField<int32_t>(verifier, VT_EXP) &&
           VerifyField<int32_t>(verifier, VT_ATTACK) &&
           VerifyField<int32_t>(verifier, VT_LV) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
  PlayerStatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PlayerStatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PlayerStat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlayerStatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PlayerStatBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cType(Class cType) {
    fbb_.AddElement<int32_t>(PlayerStat::VT_CTYPE, static_cast<int32_t>(cType), 0);
  }
  void add_HP(int32_t HP) {
    fbb_.AddElement<int32_t>(PlayerStat::VT_HP, HP, 0);
  }
  void add_HPLim(int32_t HPLim) {
    fbb_.AddElement<int32_t>(PlayerStat::VT_HPLIM, HPLim, 0);
  }
  void add_MP(int32_t MP) {
    fbb_.AddElement<int32_t>(PlayerStat::VT_MP, MP, 0);
  }
  void add_MPLim(int32_t MPLim) {
    fbb_.AddElement<int32_t>(PlayerStat::VT_MPLIM, MPLim, 0);
  }
  void add_EXP(int32_t EXP) {
    fbb_.AddElement<int32_t>(PlayerStat::VT_EXP, EXP, 0);
  }
  void add_Attack(int32_t Attack) {
    fbb_.AddElement<int32_t>(PlayerStat::VT_ATTACK, Attack, 0);
  }
  void add_LV(int32_t LV) {
    fbb_.AddElement<int32_t>(PlayerStat::VT_LV, LV, 0);
  }
  void add_ID(int32_t ID) {
    fbb_.AddElement<int32_t>(PlayerStat::VT_ID, ID, 0);
  }
  explicit PlayerStatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayerStatBuilder &operator=(const PlayerStatBuilder &);
  flatbuffers::Offset<PlayerStat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayerStat>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayerStat> CreatePlayerStat(
    flatbuffers::FlatBufferBuilder &_fbb,
    Class cType = Class_Base,
    int32_t HP = 0,
    int32_t HPLim = 0,
    int32_t MP = 0,
    int32_t MPLim = 0,
    int32_t EXP = 0,
    int32_t Attack = 0,
    int32_t LV = 0,
    int32_t ID = 0) {
  PlayerStatBuilder builder_(_fbb);
  builder_.add_ID(ID);
  builder_.add_LV(LV);
  builder_.add_Attack(Attack);
  builder_.add_EXP(EXP);
  builder_.add_MPLim(MPLim);
  builder_.add_MP(MP);
  builder_.add_HPLim(HPLim);
  builder_.add_HP(HP);
  builder_.add_cType(cType);
  return builder_.Finish();
}

flatbuffers::Offset<PlayerStat> CreatePlayerStat(flatbuffers::FlatBufferBuilder &_fbb, const PlayerStatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SendMeStatT : public flatbuffers::NativeTable {
  typedef SendMeStat TableType;
  Class cType;
  Class StatDataType;
  int32_t ID;
  SendMeStatT()
      : cType(Class_Base),
        StatDataType(Class_Base),
        ID(0) {
  }
};

struct SendMeStat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SendMeStatT NativeTableType;
  enum {
    VT_CTYPE = 4,
    VT_STATDATATYPE = 6,
    VT_ID = 8
  };
  Class cType() const {
    return static_cast<Class>(GetField<int32_t>(VT_CTYPE, 0));
  }
  Class StatDataType() const {
    return static_cast<Class>(GetField<int32_t>(VT_STATDATATYPE, 0));
  }
  int32_t ID() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CTYPE) &&
           VerifyField<int32_t>(verifier, VT_STATDATATYPE) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
  SendMeStatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SendMeStatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SendMeStat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SendMeStatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SendMeStatBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cType(Class cType) {
    fbb_.AddElement<int32_t>(SendMeStat::VT_CTYPE, static_cast<int32_t>(cType), 0);
  }
  void add_StatDataType(Class StatDataType) {
    fbb_.AddElement<int32_t>(SendMeStat::VT_STATDATATYPE, static_cast<int32_t>(StatDataType), 0);
  }
  void add_ID(int32_t ID) {
    fbb_.AddElement<int32_t>(SendMeStat::VT_ID, ID, 0);
  }
  explicit SendMeStatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SendMeStatBuilder &operator=(const SendMeStatBuilder &);
  flatbuffers::Offset<SendMeStat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SendMeStat>(end);
    return o;
  }
};

inline flatbuffers::Offset<SendMeStat> CreateSendMeStat(
    flatbuffers::FlatBufferBuilder &_fbb,
    Class cType = Class_Base,
    Class StatDataType = Class_Base,
    int32_t ID = 0) {
  SendMeStatBuilder builder_(_fbb);
  builder_.add_ID(ID);
  builder_.add_StatDataType(StatDataType);
  builder_.add_cType(cType);
  return builder_.Finish();
}

flatbuffers::Offset<SendMeStat> CreateSendMeStat(flatbuffers::FlatBufferBuilder &_fbb, const SendMeStatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BaseT : public flatbuffers::NativeTable {
  typedef Base TableType;
  Class cType;
  BaseT()
      : cType(Class_Base) {
  }
};

struct Base FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BaseT NativeTableType;
  enum {
    VT_CTYPE = 4
  };
  Class cType() const {
    return static_cast<Class>(GetField<int32_t>(VT_CTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CTYPE) &&
           verifier.EndTable();
  }
  BaseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BaseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Base> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BaseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BaseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cType(Class cType) {
    fbb_.AddElement<int32_t>(Base::VT_CTYPE, static_cast<int32_t>(cType), 0);
  }
  explicit BaseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BaseBuilder &operator=(const BaseBuilder &);
  flatbuffers::Offset<Base> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Base>(end);
    return o;
  }
};

inline flatbuffers::Offset<Base> CreateBase(
    flatbuffers::FlatBufferBuilder &_fbb,
    Class cType = Class_Base) {
  BaseBuilder builder_(_fbb);
  builder_.add_cType(cType);
  return builder_.Finish();
}

flatbuffers::Offset<Base> CreateBase(flatbuffers::FlatBufferBuilder &_fbb, const BaseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline fheaderT *fheader::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new fheaderT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void fheader::UnPackTo(fheaderT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cType(); _o->cType = _e; };
  { auto _e = PacketSize(); _o->PacketSize = _e; };
}

inline flatbuffers::Offset<fheader> fheader::Pack(flatbuffers::FlatBufferBuilder &_fbb, const fheaderT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Createfheader(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<fheader> Createfheader(flatbuffers::FlatBufferBuilder &_fbb, const fheaderT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const fheaderT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cType = _o->cType;
  auto _PacketSize = _o->PacketSize;
  return Createfheader(
      _fbb,
      _cType,
      _PacketSize);
}

inline fNetEffectT *fNetEffect::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new fNetEffectT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void fNetEffect::UnPackTo(fNetEffectT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cType(); _o->cType = _e; };
  { auto _e = EffectType(); _o->EffectType = _e; };
  { auto _e = target(); _o->target = _e; };
  { auto _e = targetMonster(); _o->targetMonster = _e; };
  { auto _e = targetPos(); if (_e) _o->targetPos = std::unique_ptr<Vec3>(new Vec3(*_e)); };
  { auto _e = StartPos(); if (_e) _o->StartPos = std::unique_ptr<Vec3>(new Vec3(*_e)); };
}

inline flatbuffers::Offset<fNetEffect> fNetEffect::Pack(flatbuffers::FlatBufferBuilder &_fbb, const fNetEffectT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatefNetEffect(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<fNetEffect> CreatefNetEffect(flatbuffers::FlatBufferBuilder &_fbb, const fNetEffectT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const fNetEffectT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cType = _o->cType;
  auto _EffectType = _o->EffectType;
  auto _target = _o->target;
  auto _targetMonster = _o->targetMonster;
  auto _targetPos = _o->targetPos ? _o->targetPos.get() : 0;
  auto _StartPos = _o->StartPos ? _o->StartPos.get() : 0;
  return CreatefNetEffect(
      _fbb,
      _cType,
      _EffectType,
      _target,
      _targetMonster,
      _targetPos,
      _StartPos);
}

inline fEquipSlotsT *fEquipSlots::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new fEquipSlotsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void fEquipSlots::UnPackTo(fEquipSlotsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cType(); _o->cType = _e; };
  { auto _e = Slot(); if (_e) { _o->Slot.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Slot[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<fEquipSlots> fEquipSlots::Pack(flatbuffers::FlatBufferBuilder &_fbb, const fEquipSlotsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatefEquipSlots(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<fEquipSlots> CreatefEquipSlots(flatbuffers::FlatBufferBuilder &_fbb, const fEquipSlotsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const fEquipSlotsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cType = _o->cType;
  auto _Slot = _o->Slot.size() ? _fbb.CreateVector(_o->Slot) : 0;
  return CreatefEquipSlots(
      _fbb,
      _cType,
      _Slot);
}

inline FirstCharacterDataT *FirstCharacterData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FirstCharacterDataT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FirstCharacterData::UnPackTo(FirstCharacterDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cType(); _o->cType = _e; };
  { auto _e = Pos(); if (_e) _o->Pos = std::unique_ptr<Vec3>(new Vec3(*_e)); };
  { auto _e = Name(); if (_e) _o->Name = _e->str(); };
  { auto _e = HP(); _o->HP = _e; };
  { auto _e = HPLim(); _o->HPLim = _e; };
  { auto _e = MP(); _o->MP = _e; };
  { auto _e = MPLim(); _o->MPLim = _e; };
  { auto _e = EXP(); _o->EXP = _e; };
  { auto _e = Attack(); _o->Attack = _e; };
  { auto _e = LV(); _o->LV = _e; };
  { auto _e = ID(); _o->ID = _e; };
}

inline flatbuffers::Offset<FirstCharacterData> FirstCharacterData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FirstCharacterDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFirstCharacterData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FirstCharacterData> CreateFirstCharacterData(flatbuffers::FlatBufferBuilder &_fbb, const FirstCharacterDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FirstCharacterDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cType = _o->cType;
  auto _Pos = _o->Pos ? _o->Pos.get() : 0;
  auto _Name = _o->Name.empty() ? 0 : _fbb.CreateString(_o->Name);
  auto _HP = _o->HP;
  auto _HPLim = _o->HPLim;
  auto _MP = _o->MP;
  auto _MPLim = _o->MPLim;
  auto _EXP = _o->EXP;
  auto _Attack = _o->Attack;
  auto _LV = _o->LV;
  auto _ID = _o->ID;
  return CreateFirstCharacterData(
      _fbb,
      _cType,
      _Pos,
      _Name,
      _HP,
      _HPLim,
      _MP,
      _MPLim,
      _EXP,
      _Attack,
      _LV,
      _ID);
}

inline fItemT *fItem::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new fItemT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void fItem::UnPackTo(fItemT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cType(); _o->cType = _e; };
  { auto _e = id(); _o->id = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = type(); _o->type = _e; };
  { auto _e = val1(); _o->val1 = _e; };
  { auto _e = val2(); _o->val2 = _e; };
  { auto _e = val3(); _o->val3 = _e; };
  { auto _e = val4(); _o->val4 = _e; };
  { auto _e = val5(); _o->val5 = _e; };
  { auto _e = val6(); _o->val6 = _e; };
  { auto _e = val7(); _o->val7 = _e; };
  { auto _e = val8(); _o->val8 = _e; };
  { auto _e = count(); _o->count = _e; };
}

inline flatbuffers::Offset<fItem> fItem::Pack(flatbuffers::FlatBufferBuilder &_fbb, const fItemT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatefItem(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<fItem> CreatefItem(flatbuffers::FlatBufferBuilder &_fbb, const fItemT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const fItemT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cType = _o->cType;
  auto _id = _o->id;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _type = _o->type;
  auto _val1 = _o->val1;
  auto _val2 = _o->val2;
  auto _val3 = _o->val3;
  auto _val4 = _o->val4;
  auto _val5 = _o->val5;
  auto _val6 = _o->val6;
  auto _val7 = _o->val7;
  auto _val8 = _o->val8;
  auto _count = _o->count;
  return CreatefItem(
      _fbb,
      _cType,
      _id,
      _name,
      _type,
      _val1,
      _val2,
      _val3,
      _val4,
      _val5,
      _val6,
      _val7,
      _val8,
      _count);
}

inline fInventoryT *fInventory::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new fInventoryT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void fInventory::UnPackTo(fInventoryT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cType(); _o->cType = _e; };
  { auto _e = Slot(); if (_e) { _o->Slot.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Slot[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<fInventory> fInventory::Pack(flatbuffers::FlatBufferBuilder &_fbb, const fInventoryT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatefInventory(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<fInventory> CreatefInventory(flatbuffers::FlatBufferBuilder &_fbb, const fInventoryT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const fInventoryT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cType = _o->cType;
  auto _Slot = _o->Slot.size() ? _fbb.CreateVector(_o->Slot) : 0;
  return CreatefInventory(
      _fbb,
      _cType,
      _Slot);
}

inline LoginT *Login::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LoginT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Login::UnPackTo(LoginT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cType(); _o->cType = _e; };
  { auto _e = isSignin(); _o->isSignin = _e; };
  { auto _e = id(); if (_e) _o->id = _e->str(); };
  { auto _e = pass(); if (_e) _o->pass = _e->str(); };
  { auto _e = isSuccess(); _o->isSuccess = _e; };
}

inline flatbuffers::Offset<Login> Login::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoginT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogin(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Login> CreateLogin(flatbuffers::FlatBufferBuilder &_fbb, const LoginT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LoginT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cType = _o->cType;
  auto _isSignin = _o->isSignin;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _pass = _o->pass.empty() ? 0 : _fbb.CreateString(_o->pass);
  auto _isSuccess = _o->isSuccess;
  return CreateLogin(
      _fbb,
      _cType,
      _isSignin,
      _id,
      _pass,
      _isSuccess);
}

inline idT *id::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new idT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void id::UnPackTo(idT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cType(); _o->cType = _e; };
  { auto _e = ID(); _o->ID = _e; };
}

inline flatbuffers::Offset<id> id::Pack(flatbuffers::FlatBufferBuilder &_fbb, const idT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Createid(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<id> Createid(flatbuffers::FlatBufferBuilder &_fbb, const idT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const idT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cType = _o->cType;
  auto _ID = _o->ID;
  return Createid(
      _fbb,
      _cType,
      _ID);
}

inline pingT *ping::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new pingT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ping::UnPackTo(pingT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cType(); _o->cType = _e; };
  { auto _e = time(); _o->time = _e; };
}

inline flatbuffers::Offset<ping> ping::Pack(flatbuffers::FlatBufferBuilder &_fbb, const pingT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Createping(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ping> Createping(flatbuffers::FlatBufferBuilder &_fbb, const pingT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const pingT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cType = _o->cType;
  auto _time = _o->time;
  return Createping(
      _fbb,
      _cType,
      _time);
}

inline testT *test::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new testT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void test::UnPackTo(testT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cType(); _o->cType = _e; };
  { auto _e = num(); _o->num = _e; };
}

inline flatbuffers::Offset<test> test::Pack(flatbuffers::FlatBufferBuilder &_fbb, const testT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Createtest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<test> Createtest(flatbuffers::FlatBufferBuilder &_fbb, const testT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const testT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cType = _o->cType;
  auto _num = _o->num;
  return Createtest(
      _fbb,
      _cType,
      _num);
}

inline PlayerT *Player::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PlayerT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Player::UnPackTo(PlayerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cType(); _o->cType = _e; };
  { auto _e = pos(); if (_e) _o->pos = std::unique_ptr<Vec3>(new Vec3(*_e)); };
  { auto _e = vel(); if (_e) _o->vel = std::unique_ptr<Vec3>(new Vec3(*_e)); };
  { auto _e = rot(); if (_e) _o->rot = std::unique_ptr<Vec3>(new Vec3(*_e)); };
  { auto _e = w(); _o->w = _e; };
  { auto _e = ID(); _o->ID = _e; };
  { auto _e = Vertical(); _o->Vertical = _e; };
  { auto _e = Horizontal(); _o->Horizontal = _e; };
  { auto _e = Jump(); _o->Jump = _e; };
  { auto _e = Attack(); _o->Attack = _e; };
  { auto _e = Anicode(); _o->Anicode = _e; };
  { auto _e = Run(); _o->Run = _e; };
}

inline flatbuffers::Offset<Player> Player::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlayerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePlayer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Player> CreatePlayer(flatbuffers::FlatBufferBuilder &_fbb, const PlayerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PlayerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cType = _o->cType;
  auto _pos = _o->pos ? _o->pos.get() : 0;
  auto _vel = _o->vel ? _o->vel.get() : 0;
  auto _rot = _o->rot ? _o->rot.get() : 0;
  auto _w = _o->w;
  auto _ID = _o->ID;
  auto _Vertical = _o->Vertical;
  auto _Horizontal = _o->Horizontal;
  auto _Jump = _o->Jump;
  auto _Attack = _o->Attack;
  auto _Anicode = _o->Anicode;
  auto _Run = _o->Run;
  return CreatePlayer(
      _fbb,
      _cType,
      _pos,
      _vel,
      _rot,
      _w,
      _ID,
      _Vertical,
      _Horizontal,
      _Jump,
      _Attack,
      _Anicode,
      _Run);
}

inline MonsterT *Monster::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MonsterT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Monster::UnPackTo(MonsterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cType(); _o->cType = _e; };
  { auto _e = pos(); if (_e) _o->pos = std::unique_ptr<Vec3>(new Vec3(*_e)); };
  { auto _e = ID(); _o->ID = _e; };
  { auto _e = TargetID(); _o->TargetID = _e; };
  { auto _e = TargetPos(); if (_e) _o->TargetPos = std::unique_ptr<Vec3>(new Vec3(*_e)); };
  { auto _e = Ani(); _o->Ani = _e; };
}

inline flatbuffers::Offset<Monster> Monster::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MonsterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMonster(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Monster> CreateMonster(flatbuffers::FlatBufferBuilder &_fbb, const MonsterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MonsterT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cType = _o->cType;
  auto _pos = _o->pos ? _o->pos.get() : 0;
  auto _ID = _o->ID;
  auto _TargetID = _o->TargetID;
  auto _TargetPos = _o->TargetPos ? _o->TargetPos.get() : 0;
  auto _Ani = _o->Ani;
  return CreateMonster(
      _fbb,
      _cType,
      _pos,
      _ID,
      _TargetID,
      _TargetPos,
      _Ani);
}

inline MonsterStatT *MonsterStat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MonsterStatT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MonsterStat::UnPackTo(MonsterStatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cType(); _o->cType = _e; };
  { auto _e = HP(); _o->HP = _e; };
  { auto _e = MAXHP(); _o->MAXHP = _e; };
  { auto _e = ID(); _o->ID = _e; };
}

inline flatbuffers::Offset<MonsterStat> MonsterStat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MonsterStatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMonsterStat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MonsterStat> CreateMonsterStat(flatbuffers::FlatBufferBuilder &_fbb, const MonsterStatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MonsterStatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cType = _o->cType;
  auto _HP = _o->HP;
  auto _MAXHP = _o->MAXHP;
  auto _ID = _o->ID;
  return CreateMonsterStat(
      _fbb,
      _cType,
      _HP,
      _MAXHP,
      _ID);
}

inline PlayerStatT *PlayerStat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PlayerStatT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PlayerStat::UnPackTo(PlayerStatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cType(); _o->cType = _e; };
  { auto _e = HP(); _o->HP = _e; };
  { auto _e = HPLim(); _o->HPLim = _e; };
  { auto _e = MP(); _o->MP = _e; };
  { auto _e = MPLim(); _o->MPLim = _e; };
  { auto _e = EXP(); _o->EXP = _e; };
  { auto _e = Attack(); _o->Attack = _e; };
  { auto _e = LV(); _o->LV = _e; };
  { auto _e = ID(); _o->ID = _e; };
}

inline flatbuffers::Offset<PlayerStat> PlayerStat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlayerStatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePlayerStat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PlayerStat> CreatePlayerStat(flatbuffers::FlatBufferBuilder &_fbb, const PlayerStatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PlayerStatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cType = _o->cType;
  auto _HP = _o->HP;
  auto _HPLim = _o->HPLim;
  auto _MP = _o->MP;
  auto _MPLim = _o->MPLim;
  auto _EXP = _o->EXP;
  auto _Attack = _o->Attack;
  auto _LV = _o->LV;
  auto _ID = _o->ID;
  return CreatePlayerStat(
      _fbb,
      _cType,
      _HP,
      _HPLim,
      _MP,
      _MPLim,
      _EXP,
      _Attack,
      _LV,
      _ID);
}

inline SendMeStatT *SendMeStat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SendMeStatT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SendMeStat::UnPackTo(SendMeStatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cType(); _o->cType = _e; };
  { auto _e = StatDataType(); _o->StatDataType = _e; };
  { auto _e = ID(); _o->ID = _e; };
}

inline flatbuffers::Offset<SendMeStat> SendMeStat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SendMeStatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSendMeStat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SendMeStat> CreateSendMeStat(flatbuffers::FlatBufferBuilder &_fbb, const SendMeStatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SendMeStatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cType = _o->cType;
  auto _StatDataType = _o->StatDataType;
  auto _ID = _o->ID;
  return CreateSendMeStat(
      _fbb,
      _cType,
      _StatDataType,
      _ID);
}

inline BaseT *Base::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BaseT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Base::UnPackTo(BaseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cType(); _o->cType = _e; };
}

inline flatbuffers::Offset<Base> Base::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BaseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBase(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Base> CreateBase(flatbuffers::FlatBufferBuilder &_fbb, const BaseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BaseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cType = _o->cType;
  return CreateBase(
      _fbb,
      _cType);
}

inline const Base *GetBase(const void *buf) {
  return flatbuffers::GetRoot<Base>(buf);
}

inline const Base *GetSizePrefixedBase(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Base>(buf);
}

inline bool VerifyBaseBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Base>(nullptr);
}

inline bool VerifySizePrefixedBaseBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Base>(nullptr);
}

inline void FinishBaseBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Base> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedBaseBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Base> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<BaseT> UnPackBase(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<BaseT>(GetBase(buf)->UnPack(res));
}

#endif  // FLATBUFFERS_GENERATED_BASE_H_
